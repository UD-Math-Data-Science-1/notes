---
jupytext:
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.11.5
kernelspec:
  display_name: 'Python 3.8.8 64-bit (''base'': conda)'
  language: python
  name: python3
---

# Introduction to numpy

The numpy package is the preferred way to interact directly with arrays in Python. We won't need much of it, but it is worth going through some key points.

```{code-cell} ipython3
import numpy as np

x = np.array([1,2,3,4,5])
x
```

Don't forget that integers and floats are different objects in Python.

```{code-cell} ipython3
x.dtype
```

```{code-cell} ipython3
np.array([1.0,2,3,4,5]).dtype
```

The `shape` of an array is what we would usually call the *size* or *dimensions* of the array.

```{code-cell} ipython3
x.shape
```

Informally, an array with one dimension may be referred to as a vector, but that is not an official designation in numpy.

```{code-cell} ipython3
def showthem(lines):
    for line in lines:
        print() 
        print(line,"=")
        print(eval(line))
    return None
```


The components of the array are referenced starting at 0.

```{code-cell} ipython3
showthem(["x[0]","x[[0,1,2]]"])
```

```{code-cell} ipython3
showthem(["x[:3]"])
```

The use of `x[:3]` above is referred to as **slicing** the array. The `:3` means to take the first three elements. If we want to reference from the end instead of the beginning, we can use negative indexes.

```{code-cell} ipython3
showthem(["x[-1]","x[-3:]"])
```

Where numpy slicing gets confusing is that in the range `i:j`, *the last index is not part of the slice.* This does mean that there are going to be $j-i$ values in the slice.

```{code-cell} ipython3
showthem(["x[1:4]"])
```

Also, numpy is happy to let you index past the end of the array. It will just return as much as is available without complaint. This can be a source of frustrating bugs.

```{code-cell} ipython3
showthem(["x[1:10]"])
```

## 2D arrays

There is no practical difference between a 2D array and an array of rows, each given as a 1D array.

```{code-cell} ipython3
A = np.array( [[1,2],[3,4],[5,6]] )
A.shape
```

You can slice in each dimension individually.

```{code-cell} ipython3
showthem(["A[-2:,:2]"])
```

A `:` in one slice position means to keep everything in that dimension.

```{code-cell} ipython3
showthem(["A[:2,:]","A[:,0]"])
```

Here are some other common ways to build arrays.

```{code-cell} ipython3
showthem(["np.ones(5)","np.zeros((3,6))","np.repeat(np.pi,3)"])
```

## Reductions

A common task is to *reduce* an array along one direction, called an *axis* in numpy, resulting in an array of one less dimension. It's easiest to explain by some examples.

```{code-cell} ipython3
showthem(["A","np.sum(A,axis=0)","np.sum(A,axis=1)"])
```

If you don't give an axis, the reduction occurs over all directions at once, resulting in a single number.

```{code-cell} ipython3
showthem(["np.sum(A)"])
```

You can also do reductions with maximum, minimum, mean, etc.

+++

## Broadcasting

You can add together arrays of the same shape, just as you would expect. Generally, you cannot do that for arrays with different shapes.

```{code-cell} ipython3
x = np.array([1,2,3,4,5])
y = np.array([10,20])
showthem(["x+x","x+y"])
```

There is a major exception though: when one of the operands can be repeated along an axis to become the same shape as the other, then this *broadcasting* is done.

```{code-cell} ipython3
showthem(["x+3","A-y"])
```

For example, suppose that for every element in a column, we want to subtract off the average value in that column. This becomes easy via broadcasting.

```{code-cell} ipython3
showthem(["A-np.mean(A,axis=0)"])
```

## Random numbers

Generating truly random numbers on a computer is not simple. Mostly we rely on *pseudorandom* numbers, which are generated by deterministic functions having extremely long periods. One nice consequence is repeatability. Given the starting "seed" or state of the random generator, you should be able to get exactly the same pseudorandom sequence every time.

We will rely on pseudorandom numbers in two ways. First, many algorithms in data science have at least one random aspect (dividing data into subsets, for example). The library routines we will be using allow you to specify the random state and get repeatable results. Occasionally, though, we might want to generate random values for our own use.

```{code-cell} ipython3
from numpy.random import default_rng
rng = default_rng(19716)  # giving an initial state to the generator
```

The `uniform` generator method produces numbers distributed uniformly (i.e., every value is equally likely) between two limits you specify.

```{code-cell} ipython3
rng.uniform(-1,1,size=(4,3))
```

Another common type of random value is generated by `normal`, which produces real values distributed according to the "bell curve" (normal or Gaussian distribution). 

```{code-cell} ipython3
rng.normal(size=(2,4))
```

In the long run, the average value of these numbers will be zero.

```{code-cell} ipython3
x = rng.normal(size=400000)
np.mean(x)
```

Results with absolute value greater than 3 should occur at a rate less than 1%.

```{code-cell} ipython3
np.mean( np.abs(x)>3 )
```

<div style="max-width:608px"><div style="position:relative;padding-bottom:66.118421052632%"><iframe id="kaltura_player" src="https://cdnapisec.kaltura.com/p/2358381/sp/235838100/embedIframeJs/uiconf_id/43030021/partner_id/2358381?iframeembed=true&playerId=kaltura_player&entry_id=1_w2pr41c8&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[leadWithHTML5]=true&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=1_1bu728r1" width="608" height="402" allowfullscreen webkitallowfullscreen mozAllowFullScreen allow="autoplay *; fullscreen *; encrypted-media *" sandbox="allow-forms allow-same-origin allow-scripts allow-top-navigation allow-pointer-lock allow-popups allow-modals allow-orientation-lock allow-popups-to-escape-sandbox allow-presentation allow-top-navigation-by-user-activation" frameborder="0" title="Kaltura Player" style="position:absolute;top:0;left:0;width:100%;height:100%"></iframe></div></div>